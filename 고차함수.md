## **CH1. 고차 함수 💁🏻**

> 다른 언어들과는 다르게 특별한 대우를 받는 게 일급 객체이고 대표적인 일급 객체가 함수입니다

-   **변수에 할당 가능**
-   다른 함수의 **전달인자로 전달** 가능(콜백 함수)
-   다른 함수의 **결과로써 리턴** 가능 (클로저 === 커링 함수) ⇒ 고차 함수는 함수를 필요한 시점에서 인자로 호출하거나 함수를 결과로 반환하는 **클로저의 형태**로 사용할 수 있습니다.

자바스크립트에서 고차 함수는 **문자열, 숫자 같은 다른 데이터처럼 사용이 가능**한 거죠!

결론적으로 고차 함수는 **불변성을 지향**하고 조건문과 반복문을 제거해서 **복잡성을 줄이고** 변수의 사용을 억제하여 상태 변경을 피하기 위해 만들었습니다. 결국 **side effect를 최대한 억제**하여 오류를 피하고 프로그램의 안전성을 높이기 위해한 노력의 방법이라고 할 수 있습니다. 

## **CH2. 내장 고차 함수(배열 내장 메서드) **💁🏻****

여기서 메서드란? 객체 프로퍼티에 저장된 함수를 '메서드'라고 부릅니다. 

#### **1\. 내장 고차 함수 Filter()**

-   모든 요소 중 내가 원하는 값만 필터링하여 반환합니다.
-   배열의 각 요소에 콜백 함수를 적용시켰을 때, true를 리턴하는 요소들만 모은 **새로운 배열**을 리턴합니다.
-   if문 대체 가능합니다.
-   기존 배열을 수정하지 않습니다.

#### **2\. 내장 고차 함수 Map(immutable)**

-   모든 요소에게 동일한 행동을 준 값에 대하여 모두 반환합니다.
-   배열의 각 요소에 콜백 함수를 적용시킨 새로운 배열을 리턴
-   기존 배열을 수정하지 않습니다.
-   forEach는 배열을 순회하며 요소 값을 참조하여 무언가를 하기 위한 함수 map은 배열을 순회하며 하나의 데이터를 다른 데이터로 맵핑하기 위한 함수입니다.

#### **3\. 내장 고차 함수 Reduce**

-   배열을 하나의 값으로 만들어 줍니다.
-   초기값을 정할 수 있습니다. 정하지 않는다면 배열의 첫 번째 요소가 초기값이 됩니다.
-   배열의 각 요소를 콜백 함수에 맞게 **하나로 응축**시킨 값을 리턴합니다.
-   **(누적 값, 현재 값, 초기값)**이 가장 중요한 키워드입니다. 

ㄱ. 초기값이 없을 때

-   **acc****umulation(응축된 값)은** 배열의 첫 번째 값 ⇒ 배열\[0\]
-   **cur****rent(현재 값)은** 배열의 두 번째 값 ⇒ 배열\[1\]
-   acc + cur 이다음 acc 가 되는 것

ㄴ. 초기값이 있을 때

-   **accumulation(응축된 값)은** 초기값
-   **cur****rent(현재 값)은** 배열의 첫 번째 값 ⇒ 배열\[0\]
-   acc + cur 이다음 acc 가 되는 것

## **CH3. 여기서 고차 함수를 쓰는 이유는 무엇일까요? ****💁🏻****  ⇒  추상화 (생산성의 향상)**

추상화는 복잡한 어떤 것을 압축해서 핵심만 추출한 상태로 만드는 것입니다. 프로그래밍 언어도 추상화의 결과라고 할 수 있습니다. 컴퓨터 내부 연산에 대해서 고민하지 않고 코드를 작성하면 프로그램을 만들 수 있으므로 생산성을 향상할 수 있는 것이죠.

함수도 추상화의 좋은 사례라고 합니다. 함수는 값 수준의 추상화이지만 고차 함수는 사고의 추상화로 끌어올리는 것이고 이를 통해 생산성의 향상으로 이어지는 거라고 합니다만.... 이해가 잘되지 않습니다.... 결론적으로는 생산성의 향상을 위해 사용한다고 이해하고 넘기려고 합니다. 

## **CH4. 고차함수 예제 풀이**

#### **28.getLengthOfLongestElement**

-   문제 : 문자열을 요소로 갖는 배열을 입력받아 배열에서 가장 긴 문자열의 길이를 리턴해야 합니다.
-   주의사항 : 반복문(for, while) 사용은 금지됩니다. / 빈 배열을 입력받은 경우, 0을 리턴해야 합니다.

```
function getLengthOfLongestElement(arr) {
  if(arr.length === 0) return 0;
  return arr.reduce((acc,cur) => {
    if(acc.length >= cur.length) return acc;
    else return cur;
  }).length
}
```

⇒  제가 헤맸던 부분은 return 부분에 acc.length를 해서 바로 결괏값으로 보내면 된다고 생각을 했습니다! 근데 오류가 나더라고요. 콘솔로 찍어보니 return acc.length로 현재 값을 설정해버리면 다음 배열의 값과 비교를 할 때 배열의 string이 아닌 배열의 길이가 넘어가서 그 값의 길이를 비교해버렸습니다. 결론적으로 reduce함수로 값을 비교할 땐 원본 값만 비교하도록 해야 합니다. 

#### **31.studentReports**

-   문제 : 학생의 정보가 담긴 객체를 요소로 갖는 배열을 입력받아 아래 조건에 맞게 변형된 배열을 리턴해야 합니다.
-   1.  남학생들의 정보는 리턴하는 배열에서 제외합니다.
    2.  'grades' 속성값은 평균값(number 타입)으로 바꿉니다.

```
function studentReports(students) {
  // 1. gender === "female"을 필터로 걸러냄
  // 2. students.grades의 평균을 구해서 다시 넣어줌 ..? reduce/배열의 길이나눠줌 

  const filteredStudents = students.filter(el => el.gender === "female");

  filteredStudents.forEach(el => {
    el.grades = el.grades.reduce((acc,cur) => acc + cur ) / el.grades.length;
  })
  return filteredStudents;
}
```

⇒  저는 여기서 forEach를 하나의 변수에 할당해서 return을 해주었었습니다. 그랬더니 결괏값으로 undefined가 나오더라고요. 이유를 찾아보니 forEach가 map 메서드와의 차이점은 따로 콜백 함수가 return 하는 값을 따로 모아서 어떤 처리를 하는 과정이 없기 때문에 , 메서드를 호출한 코드를 함수에 할당하면 undefined가 할당된다고 합니다. 데이터가 return 할 수가 없는 구조인 것 같다. 단순하게 동작만을 한다고 생각을 했습니다.
