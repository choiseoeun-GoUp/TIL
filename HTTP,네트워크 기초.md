# CH1. 웹 **애플리케이션 아키텍처** 💁🏻

## **1. 클라이언트 - 서버 아키텍쳐**

> **리소스가 존재하는 곳과 리소스를 사용하는 앱을 분리시킨것을 클라이언트-서버 아키텍처**라고 하며 **2티어 아키텍처**라고도 부릅니다. 리소스 사용 = 클라이언트, 리소스 제공 = 서버
> 
- 리소스를 가지고있는 서버에게 클라이언트는 **요청**을 하고, 요청에 따라 서버는 **응답**을 합니다.
- **리소스를 사용하는 앱 = 클라이언트**
- **리소스를 전달해주는 앱 = 서버**
- **리소스를 저장하는 공간 =  데이터베이스 ⇒ 3-Tier아키텍처 라고 함**
- EX) 클라이언트는 보통 웹사이트나 앱 이고, 서버는 기능에 따라 파일제공 서버, 메일을 주고받는 서버등이 있고 데이터베이스도 일종의 서버입니다.

## 2. 클라이언트 - 서버 통신과 API

클라이언트와 서버 간의 통신은 **요청과 응답**으로 구성됩니다. 요청이 있어야만 응답이 옵니다. 클라이언트-서버 아키텍쳐에서는 **서버 마음대로 클라이언트에 리소스를 전달하지 않습니다.** 

### a.프로토콜

- **프로토콜은 통신규약**(약속), 즉 **데이터를 송수신하기 위한 규칙**을 말합니다. → 직원에게 주문을 하기 위해서는 몇가지 규칙이 있습니다.
- 통신하기 위한 다양한 방법이 있습니다. → 직원에게 주문을 할때 앱,키오스크 등 여러가지 주문방법이있다. 이러한 **다양한 방법하나하나를 전부 프로토콜**이라고 할 수 있습니다.
- 대표적으로 **HTTP라는 프로토콜**이 있습니다.

### b.OSI 7 Layers

응용계층 → 표현계층 → 세션계층 → 전송계층 →네트워크 계층 → 데이터 링크 → 물리

### c.API

- 손님이 메뉴판을 보고 주문을 해야합니다. 컴퓨터세계에서는 0과 1로 변환된 요청을 원합니다. 정확한 주문방법에 따라 요청해야합니다. 하지만 서버가 어떻께 구성되어있는지 우리는 모릅니다. 클라이언트(주문자)가 어떻게 서버에게 필요한 자원을 확일할수있을까요 → **서버는 클라이언트에게 리소스를 잘 활용할 수 있도록 인터페이스를 제공**해줘야 합니다. 이것을 **API**라고합니다.
- **API는 Application Programming Interface 약자**입니다.→ 이 중 인터페이스는 의사소통이 가능하도록 만들어진 접점이며 메뉴판이 인터페이스 입니다. (추상화?)
- 그중 **사용자 관리 API**는 HTTP API에서 모범사례입니다. 보통 인터넷에 있는 데이터를 요청할때는 HTTP라는 프로토콜을 사용하며 주소를 통해 접근할 수 있는데 여기에 메소드라는 개념이 더해진것입니다.
- HTTP 요청 메서드의 종류
    
    
    | 요청 | 적절한 메소드 |
    | --- | --- |
    | 조회(Read) | GET |
    | 추가 (Creat) | POST |
    | 갱신 (Update) | PUT 또는 PATCH |
    | 삭제 (Delete) | DELETE |

# CH2. 브라우저의 작동원리(보이지 않는 곳) 💁🏻

## 2-1. URL과 URI

- **URL**은 Uniform Resource Locator의 줄임말로, **네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보**를 나타냅니다.
- **URI**는 Uniform Resource Identifier의 줄임말로, 일반적으로 **URL의 기본 요소인 scheme, hosts, url-path에 더해 query, bookmark를 포함**합니다. query는 웹 서버에 보내는 추가적인 질문입니다. → 브라우저의 검색창을 클릭하면 나타나는 주소
- **URI는 URL을 포함하는 상위개념**입니다.
    
    
    | 부분 | 명칭 | 설명 |
    | --- | --- | --- |
    | file://, http://, https:// | scheme | 통신 프로토콜 |
    | 127.0.0.1, www.google.com | hosts | 웹페이지, 이미지, 동영상 등의 파일이 위치한 웹 서버, 도메인 또는 IP |
    | :80, :443, :3000 | port | 웹 서버에 접속하기 위한 통로 |
    | /serch, /Users/username/Desktop | url-path | 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상 등의 파일의 위치까지의 경로 |
    | q=JavaScript | query | 웹 서버에 전달하는 추가 질문 |
    - 이미지
        

## 2-2. IP 와 포트

### a. IP

- **네트워크에 연결된 특정 PC의 주소를 나타내는 체계**를 IP address라고 합니다.
- **IP**는 **Internet Protocol**의 줄임말로, **인터넷상에서 사용하는 주소체계**를 의미합니다.
- **IPv4**는 **Internet Protocol version 4**의 줄임말로, **IP 주소체계의 네 번째 버전**을 뜻합니다
- `localhost`, `127.0.0.1` : 현재 사용 중인 로컬 PC를 지칭합니다.
- `0.0.0.0`, `255.255.255.255` : broadcast address, 로컬 네트워크에 접속된 모든 장치와 소통하는 주소입니다. 서버에서 접근 가능 IP 주소를 broadcast address 로 지정하면, 모든 기기에서 서버에 접근할 수 있습니다.

### b. PORT

- 로컬 PC의 IP주소인 127.0.0.1 뒤에 :3000과 같은 숫자가 표현되는데 이는 IP주소가 가리키는 PC에 접속할 수 있는 통로를 의미합니다. **서버에 접속할 수 있는 통로, 생략 가능**
- 이미 사용중인 포트는 중복해서 사용할 수 없기때문에 3000이 다른 프로그램에서 쓰이고있다면 3001로 프로그램이 실행 될 것입니다.
- 잘알려진 포트번호
- 22 : SSH
- 80 : HTTP
- 443: HTTPS

## 2-3. 도메인과 DNS

### a. Domain name

- **도메인은 IP주소 를 대신하여 사용하는 주소**입니다. 예를들어 IP주소가 지번 또는 도로명 주소라면 도메인 이름은 해당주소에 위치한 상호입니다.
- 한눈에 파악하기 힘든 **IP주소를 보다 간단**하게 나타낼 수 있습니다.
- 터미널에서 도메인 이름을 통해 IP 주소를 확인하는 명령어 `nslookup`으로 특정사이트의 IP 주소를 확인할 수 있습니다. → oooo.com이 도메인입니다.

### b. DNS

- **도메인 이름과 매칭된 IP주소를 확인하는 작업을 실행하는 서버**를 DNS(Domain Name System)라고 합니다.
- 호스트의 도메인 이름을 IP 주소로 변환하거나 반대의 경우를 수행할 수 있도록 개발된 데이터베이스 시스템

# CH3. HTTP(HyperText Transfer Protocol) 💁🏻

클라이언트와 서버가 통신을 할때 필요한 규약 

한번의 요청에는 한번의 응답이 있다.

## 3-1. HTTP Message

### a. HTTP Message

> 클라이언트와 서버 사이에서 **데이터가 교환되는 방식**으로 **요청(**Requests)과 **응답**(Responses)이 있습니다.
> 


1. start-line : 요청이나 응답의 상태, 응답에서는 status line이라고 부름
2. HTTP headers :  요청을 지정하거나, 메세지에 포함된 본문을 설명하는 헤더의 집합
3. empty line : 헤더와 본문을 구분하는 빈줄
4. body : 요청 및 응답과 관련된 데이터 또는 문서를 포함

### b. Stateless(무상태성)

- HTTP의 큰특징으로 상태를 가지지 않는다는 뜻입니다. HTTP로 클라이언트와 서버가 통신을 주고 받는 과정에서, HTTP는 통신규약일 뿐이므로 클라이언트나 서버의 상태를 확인하거나 저장하지 않습니다. 따라서 필요에 따라 다른방법(쿠키-세션, API등)을 통해 상태를 확인할 수 있습니다.

## 3-2. HTTP Requests

클라이언트가 서버에게 보내는 메세지입니다.

### a. Start line

- 수행할 작업(GET, PUT, POST 등)이나 방식(HEAD or OPTIONS)을 설명하는 HTTP method를 나타냅니다.
- 요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성됩니다.

### b. Headers

- 헤더 이름(대소문자 구분이 없는 문자열), 콜론( : ), 값을 입력합니다. 값은 헤더에 따라 다릅니다. 여러 종류의 헤더가 있고, 다음과 같이 그룹을 나눌 수 있습니다.
- General headers : 메시지 전체에 적용되는 헤더로, body를 통해 전송되는 데이터와는 관련이 없는 헤더입니다.
- Request headers : fetch를 통해 가져올 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더를 의미합니다.
- Representation headers : body에 담긴 리소스의 정보(콘텐츠 길이, MIME 타입 등)를 포함하는 헤더입니다.

### c. Body

- 요청의 본문은 마지막에 위치합니다. 모든 요청에 필요한것은 아닙니다.
- GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우 즉, 서버에 있는 데이터들을 요청하는 경우에는 body가 필요하지 않습니다.
- body는 다음과 같은 두 종류로 나눌 수 있습니다.
- Single-resource bodies(단일-리소스 본문) : 헤더 두 개로 정의된 단일 파일로 구성됩니다.
- Multiple-resource bodies(다중-리소스 본문) : 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지닙니다.

## 3-3. HTTP Responses

서버가 클라이언트에게 보내는 메세지입니다.

### a. Start line

1. 현재 프로토콜의 버전(HTTP/1.1)
2. 상태 코드 - 요청의 결과를 나타냅니다. (ex. 200, 302, 404 등)
3. 상태 텍스트 - 상태 코드에 대한 설명
- ex) HTTP/1.1 404 Not Found

### b. Headers

- 응답에 들어가는 HTTP headers는 요청 헤더와 동일한 구조

### c. Body

- 모든 응답에 body가 필요하지는 않습니다.

# CH4. 브라우저의 작동 원리 (보이는 곳) 💁🏻

## 4-1. AJAX

> AJAX는 Asynchronous JavaScript And XMLHttpRequest의 약자로, JavaScript, DOM, Fetch, XMLHttpRequest, HTML 등의 다양한 기술을 사용하는 **웹 개발 기법**입니다. 가장 큰 특징은, **웹페이지에 필요한 부분에 필요한 데이터만 비동기적으로 받아**와서 화면에 나타낼 수 있습니다.
> 

### a. AJAX의 두 가지 핵심 기술 : JavaScript와 DOM, 그리고 Fetch

전통적인 웹 어플리케이션은 form 태그를 이용해서 서버에 데이터를 전송했고 새로운 웹페이지를 제공했습니다. 하지만 **Fetch를 사용하면 비동기적으로 페이지를 이동하지 않아도 서버로부터 데이터를 받아** 올 수 있습니다.

Fetch이전에는 XHR(XMLHttpRequests)를 사용했으나 XHR은 cross-site 이슈 등이 있고, fetch는 promise 지원 등의 장점이 있기 때문에 오늘날 많이 사용됩니다. 

### b. AJAX의 장점

- 서버에서 HTML을 완성하여 보내주지 않아도 **필요한 데이터를 비동기적으로 가져와 화면의 일부만 업데이트** 하여 웹페이지를 만들 수 있습니다.
- 표준화된 방법입니다.
- 유저 중심 어플리케이션 개발이 가능합니다. → 일부분만 렌더링하여 빠름
- 대역폭(네트워크 통신 한번에 보낼 수 있는 데이터의 크기)이 작습니다.

### c. AJAX의 단점

- Search Engine Optimization(SEO)에 불리합니다. → 검색사이트에서는 전 세계 사이트를 돌아다니면서 각 사이트의 모든 정보를 긁어와야하는데 AJAX방식의 웹어플리케이션의 HTML은 뼈대만 있고 데이터는 없기 때문에 사이트의 정보를 긁어가기 어렵습니다.
- 뒤로가기 버튼이 동작하지 않습니다. → AJAX에는 이전 상태를 기억하지 않습니다. 별도로 History API를 사용해야합니다.

## 4-2. SSR 과 CCR

### a.SSR(Server Side Rendering)

- 웹페이지를 브라우저에서 렌더링하는 대신에 서버에서 렌더링합니다. **서버에서 웹페이지를 브라우저로 보내기전에 서버에서 완전히 렌더링** 됩니다.
- **SEO**(검색 엔진 최적화)가 **우선**인 경우
- 웹페이지의 **첫 화면 렌더링이 빠르게 필요**한 경우
- 사용자의 **상호작용이 적은** 경우
- EX) 네이버 블로그 , 신문사 홈페이지(빠르게 뉴스 노출필요)

### b.CCR(Client Side Rendering)

- **클라이언트 측에서 페이지를 렌더링**합니다. 서버에서는 웹페이지와 JavaScript를 보내고 클라이언트는 웹페이지를 받고,JavaScript파일은 브라우저의 웹페이지를 완전히 렌더링된 페이지로 바꿉니다.
- **SEO**(검색 엔진 최적화)가 **우선이 아닌** 경우
- 사이트에 **상호작용이 많은** 경우, 빠른 라우팅으로 강력한 사용자 경험 제공
- 웹어플리케이션은 **빠른 동적 렌더링이 필요**하므로 적합
- EX) 아고다 같은 SPA를 기반으로 만들어진 웹
