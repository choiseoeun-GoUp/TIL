# **CH1. 클래스와 인스턴스 💁🏻**

### 1. 객체 지향 프로그래밍

객체 지향 프로그래밍은 하나의 모델이 되는 청사진(blueprint)을 만들고, 그 청사진을 바탕으로 한 객체를 만드는 프로그래밍 패턴입니다. 이러한 객체는 인스턴스 객체(instance object), 줄여서 인스턴스(instance)라고 부릅니다. 청사진은 클래스(class)라고 부릅니다. 

- new키워드를 사용해서 새로운 인스턴스를 생성합니다.

```jsx
function singer(song){} // 클래스

let beyonce = new singer("love on top","...","..."); // 인스턴스
let bts = new singer("...","...","..."); // 인스턴스
```

⇒ 즉시 생성자 함수가 실행되며, 변수에 클래스의 설계를 가진 새로운 객체(인스턴스)가 할당됩니다. 인스턴스는 클래스의 고유한 속성과 메서드를 갖게됩니다. 

### 2. ES5 vs ES6 객체의 생성

- ES5 에서는 클래스를 함수로 정의 할 수있습니다.

```jsx
// 클래스 : 속성의 정의
funcrion ES5singer(song,name,prize){
	this.노래 = song; // 인스턴스 객체를 의미하는 this
	this.이름 = name; // 만들어진 인스턴스에 해당 이름,노래,상을 부여하겠다는 의미
}

// 클래스 : 메소드의 정의
Singer.prototype.HowtoMakeSong = function(){
	console.log("노래를 어케어케 만든다")//작곡을 구현하는 코드 
}

//인스턴스에서의 사용
let beyonce = new ES5singer("love on top","...","...");
beyonce.song; // "love on top"
beyonce.HowtoMakeSong() // "노래를 어케어케 만든다"
```

- ES6 에서는 class라는 키워드를 이용해서 정의할 수도 있습니다.

```jsx

class ES6singer {
// 클래스 : 속성의 정의
	constructor(song,name,prize){
		this.노래 = song; // 인스턴스 객체를 의미하는 this
		this.이름 = name;
	}

// 클래스 : 메소드의 정의
	HowtoMakeSong(){
		console.log("노래를 어케어케 만든다")
	}
}

//인스턴스에서의 사용
let beyonce = new ES6singer("love on top","...","...");
beyonce.song; // "love on top"
beyonce.HowtoMakeSong() // "노래를 어케어케 만든다"
```

 

### 3. prototype, constructor, this

# **CH2. 객체 지향 프로그래밍(OOP) 💁🏻**

### 1. 객체 지향 프로그래밍(Object Oriented Programming)

OOP(객체 지향 프로그래밍)이란 **문제를 여러개의 객체 단위로 나눠 작업하는 방식**으로, **객체들이 서로 유기적으로 상호작용하는 프로그래밍 이론** 입니다. 

- 대표적으로 Java와 C#이 객체지향 프로그래밍 언어 입니다.
- “클래스” 라고 부르는 데이터 모델의 청사진을 사용해 코드를 작성합니다.
- OOP의 모든것은 “객체”로 그룹화 됩니다.
- 코드 재 사용성을 얻을 수 있습니다.

### 2. 캡슐화(Encapsulation)

> **캡슐화**란 **데이터와 코드의 형태를 외부로부터 알 수없게**하고, **데이터의 구조와 역할,기능을 하나의 캡슐형태로 만드는 방법**입니다.
> 
- 디테일 한 구현이나 데이터는 숨기고, 객체 외부에서 필요한 동작(메소드)만 노출시킬수있는 **은닉화**의 특징을 갖고 있습니다.
- 캡슐화의 목적은 속성의 직접적인 접근을 막고, 설정하는 함수(setter), 불러오는 함수(getter)등의 메소드를 통해서만 간접적으로 접근을 허용합니다.

### 3. 추상화(Abstaction)

> **추상화**란 내부구현은 아주 복잡한데, 실제로 노출되는 부분은 **단순**하게 만드는 것입니다.
> 
- 추상화의 개념을 통해 인터페이스가 단순해 집니다. 많은 기능의 노출을 막아줍니다.
- 캡슐화는 코드나 데이터의 은닉에 포커스가 맞춰져있다면, 추상화는 클래스를 사용하는 사람이 필요하지 않은 메소드 등을 노출시키지 않고, 단순한 이름으로 정의하는것에 포커스가 맞춰져있습니다.
- 정리하면 추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법입니다.

### 4. 상속(Inheritance)

> **상속**은 **부모 클래스의 특징을 자식 클래스가 물려**받는 것입니다. 더 정확히 말하면 기본클래스의 특징을 파생클래스가 상속받는 것입니다.
> 
- 상위 클래스의 기능을 가져와 재사용이 가능하고 동시에 하위클래스에 새로운 기능을 추가 할 수있습니다.
- 상속이 필요한 이유는 코드의 중복을 없애기 위해서 입니다.

### 5. 다형성(Polymorphism)

> **다형성**이란 상속와 연관있는 개념으로 한 객체가 상속의 통해 **다른 방식으로 재구성**되는 것입니다.
> 
- 다형성의 핵심은 상속받은 하위클래스들이 조금씩 다르게 작동합니다. 같은 이름을 가졌더라도 각자의 특징에 맞게 재 창조할 수 있습니다.

다시한번 정리하자면 OOP는 위의 네가지 특성들을 통해 어떤 것을 **추상화**하여 공통된 특성을 파악해 정리 하였고, 이것을 **캡슐화** 하여 하나의 캡슐형태로 모아 객체를 만들고, 다른 자식 요소가 **상속**받아 재 사용을 합니다. 상속받은 자식요소는 **다형성**을 통해 다른 방식으로 재구성 할 수있습니다. 

# **CH3. 프로토타입 💁🏻**

### 1. 프로토타입이란

클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 객체(인스턴스)를 생성합니다. 하지만 프로토타입 기반 **객체지향 프로그래밍 언어는 클래스 없이도 객체를 생성**할 수있습니다. 

자바스크립트의 모든 객체는 자신의 부모 역할인 객체와 연결되어 있습니다. 마치 상속의 개념과 같이 부모객체의 프로퍼티 또는 메소드를 상속받아 사용 할 수있습니다. 이러한 **부모 객체를 prototype**이라고 합니다. 

> Prototype이란 **객체의 특성을 다른 객체로 상속하는 것을 가능하게 하는 메커니즘**입니다. **상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 `prototype`이라는 속성**에 정의되어있습니다.
> 
- 자바스크립트의 모든 객체는 프로토타입이라는 객체를 가지고 있습니다.
- 모든 객체는 그들의 프로토타입으로부터 프로퍼티와 메소드를 상속받습니다.
- 자바스크립트의 모든 객체는 최소한 하나 이상의 다른 객체로 부터 상속을 받으며, 이때 상속되는 정보를 제공하는 객체를 프로토타입이라고합니다.

### 2. .prototype

- 상속 받는 메소드들이 정의된 상위요소입니다. 생성자를 가지는 원형으로 선언 할 수있습니다.
- .prototype을 이용하면 현재 존재하고 있는 프로토타입에 새로운 프로퍼티나 메소드를 추가 할 수있습니다.
- 함수 객체만 가지고 있습니다.

### 3. .__protp__(접근자 프로퍼티)

- 모든 객체는 **.__proto__** 를 통해 자신의 프로토타입([[prototype]]내부슬롯) 에 접근 할 수있습니다.
- 상속을 통해서 사용됩니다. 객체가 직접 소유하는 프로퍼티가 아니라 object.prototype의 프로퍼티입니다.
- 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서입니다.

### 4. 클래스, 인스턴스, 프로토타입의 관계

자바나 C++같은 클래스 기반의 언어들은 클래스와 인스턴스를 구별되는 개념으로 생각합니다. 

- 클랫스는 특정 객체군을 특징 짓는 모든 속성들을 정의합니다. 예를 들어, 가수클래스는 가수들을 대표 할수있습니다.
- 반면 인스턴스는 클래스를 기반으로 실체화된 것입니다. 예를들어, 비욘세는 특정 가수를 나타내는 가수클래스의 인스턴스가 될 수있습니다. 인스턴스는 부모 클래스의 속성과 동일한 속성들을 가집니다.

하지만 자바스크립트같은 프로토타입 기반의 언어들은 클래스와 인스턴스의 차이를 두지 않습니다. 간단하게 객체를 가질뿐입니다. 

- 모든 객체는 하나의 프로토타입을 갖습니다. 그리고 모든 프로토타입은 생성자 함수와 연결되어있습니다.
